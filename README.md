# DistributedSystemsStudy

## paper
 https://lamport.azurewebsites.net/pubs/time-clocks.pdf

gpt 요약 - 논문 요약
```
다음은 Leslie Lamport의 고전 논문 **“Time, Clocks, and the Ordering of Events in a Distributed System”**(1978)에 대한 한국어 요약입니다. 이 논문은 분산 시스템에서의 **이벤트(event)** 간 순서를 정의하고, 이를 위해 **논리적 시계(logical clock)** 개념을 제안합니다.

---

## 1. 문제 제기와 동기
- **분산 시스템**에서 여러 프로세스는 물리적으로 다른 컴퓨터(노드)에서 독립적으로 동작합니다.
- 이 노드들은 서로 **메시지**를 교환하며 협력해야 하지만, 네트워크 지연과 노드 간 물리 시간의 차이 때문에 사건(이벤트)의 “순서”를 어떻게 정의하고 유지할지가 어려운 문제입니다.
- Lamport는 물리 시계가 불완전하거나 비동기화될 수 있으므로, **논리적인 기준**을 사용해 이벤트 간의 순서를 매기는 방법이 필요하다고 주장합니다.

---

## 2. “happened-before” 관계
- Lamport는 이벤트 간 **원인-결과(causality)** 관계를 정의하기 위해 “\(\rightarrow\)” 기호로 나타내는 **“happened-before”** 관계(발생 선후 관계)를 제안합니다.
  1. 한 프로세스 내에서 시간상 먼저 일어난 이벤트 \(a\)가 뒤에 일어난 이벤트 \(b\)보다 “앞서” (i.e., \(a \rightarrow b\)) 있다고 정의합니다.
  2. 어떤 프로세스 \(P\)에서 발생한 이벤트 \(a\)가 메시지 전송을 통해 다른 프로세스 \(Q\)의 이벤트 \(b\)에 영향을 주면(즉 \(a\)가 \(b\)를 야기했다면), \(a \rightarrow b\)로 정의합니다.
  3. 위 두 규칙을 **추론적**으로 확장하여, \(\rightarrow\) 관계가 전이적(transitive)인 것을 이용해 전체 분산 시스템에서 이벤트들의 순서를 정합니다.

- 이 관계는 물리 시간이 아닌 **논리적 인과관계**를 나타냅니다. 즉, 하나의 사건이 다른 사건에 영향을 줄 수 있는지 여부에 집중합니다.

---

## 3. 논리적 시계(Logical Clock)
- **논리적 시계**는 각 프로세스마다 하나씩 존재하며, 이벤트가 발생할 때마다 증가시키는 **카운터** 방식입니다.
- Lamport가 제안한 알고리즘 개요:
  1. **Local Event**: 프로세스 내 이벤트가 발생할 때마다, 해당 프로세스의 시계를 +1 증가시킵니다.
  2. **Send Event**: 메시지를 전송할 때, 메시지에 **현재 프로세스 시계값**을 담아서 보냅니다.
  3. **Receive Event**: 메시지를 수신하면, 수신 측 프로세스 시계값을 \(\max(\text{수신 측 시계값}, \text{메시지에 담긴 시계값}) + 1\)로 설정합니다.

- 이를 통해 **각 이벤트에 논리 시계값(타임스탬프)**을 할당할 수 있고, 시계값이 작은 이벤트가 원칙적으로 먼저 일어났다고 간주합니다(`\(L(a) < L(b) \implies a \rightarrow b\)`).

---

## 4. 전체 순서(Total Ordering)와 활용
- 논리 시계만으로는 어떤 이벤트들이 동시에 발생했는지(인과관계가 없음)를 표시할 수 있습니다. 예컨대 \(L(a) = L(b)\)인 상황입니다.
- Lamport는 이를 확장해, **동시에 발생한 이벤트**를 구별할 필요가 있을 경우, 프로세스 ID 등을 활용해 **토탈 오더링(total ordering)**을 정의할 수 있다고 설명합니다.
- 이 방법은 **분산 뮤텍스** 알고리즘, **분산 데이터베이스의 트랜잭션 순서 보장** 등 다양한 분산 시스템 문제를 해결하는 토대가 됩니다.

---

## 5. 시사점
1. **인과관계(causality) vs 물리 시간**
   - 논문은 실제 물리 시간을 정확히 맞추기 힘든 분산 환경에서, “인과관계”를 기준으로 이벤트 순서를 정의하는 것이 얼마나 중요한지 보여줍니다.
2. **개념적 단순성**
   - 단순한 카운터(논리적 시계)만으로도 분산 시스템에서 필수적인 동작을 충분히 설명하고 조율할 수 있다는 점이 큰 시사점을 줍니다.
3. **추가 연구의 시발점**
   - Lamport의 이 논문 이후, **Vector Clock**, **Matrix Clock**, **Version Vector** 등 더 정교한 논리 시계 구조가 발전하였습니다.

---

## 6. 결론
Lamport의 “Time, Clocks, and the Ordering of Events in a Distributed System”은 **분산 환경**에서 이벤트 간 순서를 정의하기 위한 **개념적 토대**를 마련한 역사적 논문입니다. 논리적 시계를 통해 인과관계를 유지하며, 이를 토대로 분산 시스템에서 동기화, 뮤텍스, 트랜잭션 일관성 등 핵심 문제를 해결할 수 있는 아이디어가 여기서 비롯되었습니다.

> **핵심 요점**:
> - 실제 물리 시간 대신, **인과관계**와 **논리적 시계**에 기반한 “이벤트 순서” 정의.
> - 분산 시스템 문제에서 “누가 먼저 발생했는가”를 간단한 알고리즘으로 해결.

이상이 논문의 전체적인 요지와 핵심 내용입니다. 추가적으로 특정 부분에 대한 자세한 해설이 필요하시다면 말씀해 주세요.
```

## 아이디어 확장 - **Vector Clock**, **Matrix Clock**, **Version Vector**

```
**Vector Clock**, **Matrix Clock**, **Version Vector**는 모두 **분산 시스템에서 이벤트(또는 버전)의 순서를 추적**하기 위한 자료구조 혹은 알고리즘입니다. **Lamport Clock**보다 더 정교하게 **인과관계(causality)**를 파악하거나 **동시성**을 식별하기 위해 발전한 개념들이라고 볼 수 있습니다.

아래에서는 각각을 **쉽게** 설명해 드리겠습니다.

---

## 1. Vector Clock

### 1) 어떤 문제를 해결하려고 하나?
- Lamport Clock은 이벤트 간의 ‘인과관계’를 어느 정도 파악할 수 있지만, 이벤트가 “동시에 발생했는지”, “서로 독립적인지”와 같은 것을 세밀하게 구분하기 어렵습니다.
- **Vector Clock**은 **각 프로세스(노드)**에서 **모든 프로세스**를 나타내는 **카운터**를 유지함으로써, **더 정확한 동시성 정보**를 표현하려고 합니다.

### 2) 어떻게 생겼나?
- 예를 들어, 프로세스가 3개(A, B, C) 있다면, 각 프로세스는 길이가 3인 벡터 \([v_A, v_B, v_C]\)를 관리합니다.
  - **A 프로세스**의 벡터: \([x_A, x_B, x_C]\)
  - **B 프로세스**의 벡터: \([y_A, y_B, y_C]\)
  - **C 프로세스**의 벡터: \([z_A, z_B, z_C]\)

### 3) 기본 동작 원리
1. **로컬 이벤트 발생**: 자기 자신의 벡터에서 자기 인덱스를 +1 증가.
   - 예: A가 이벤트를 하나 처리하면, A의 벡터에서 \(`A` 위치)\를 +1.
2. **메시지 전송**: 메시지에 **현재 벡터**를 실어서 보냄.
3. **메시지 수신**: 수신 측 프로세스는
   - **수신한 벡터**와 **자신의 벡터**를 **각 원소별로 최대값**을 취한 뒤 +1(혹은 자신의 인덱스만 +1)
   - 즉, `myVector[i] = max(myVector[i], receivedVector[i])` for all i.
     - 그리고 로컬 이벤트로 취급해서 자신 인덱스를 +1 증가(구현마다 살짝 다름).

### 4) 무엇을 알 수 있나?
- 두 벡터 \(\vec{V}\)와 \(\vec{W}\)를 비교해, “\(\vec{V}\)가 전체적으로 \(\vec{W}\) 이상”인지(\(\forall i, V[i] \ge W[i]\))를 보면, **인과관계**(V가 W보다 나중에 발생)인지, 아니면 **독립**(동시에 발생) 관계인지 구분 가능.
- 덕분에 **어떤 이벤트가 먼저인가**, **두 이벤트가 동시에 일어났는가**를 보다 정밀하게 추적할 수 있습니다.

---

## 2. Matrix Clock

### 1) Vector Clock에서 왜 확장되었나?
- Vector Clock은 “내가 알고 있는 전체 프로세스들의 시계 상태”를 벡터로 저장합니다.
- 그런데, 내가 “다른 프로세스가 서로 간에 어떻게 인과관계를 이해하고 있는지”까지 추적하려면, 더 많은 정보가 필요합니다.

### 2) 구조
- **Matrix Clock**은 프로세스별로 유지되는 **\(N \times N\) 행렬** 구조입니다(N은 프로세스 수).
  - 예: 프로세스 \(i\)가 갖는 행렬을 \(M_i\)라고 하면, \(M_i[j, k]\)는 “프로세스 \(j\)가 보고 있는 프로세스 \(k\)의 이벤트 시계”를 의미합니다.
- 즉, 각 프로세스는 **‘모든 프로세스의 벡터 시계’를 다 모아서** 2차원 정보로 저장한다고 볼 수 있습니다.

### 3) 동작 예시
1. **프로세스 \(i\)에서 이벤트 발생**:
   - \(M_i[i, i]\)를 +1(내가 나 자신에 대해 알고 있는 시계값 증가).
2. **프로세스 \(i\)가 \(j\)에게 메시지**:
   - 메시지에 **행렬 \(M_i\)** 전체를 담아서 전송(또는 필요한 정보만).
3. **프로세스 \(j\)가 수신**:
   - **수신한 행렬**과 **자기 행렬 \(M_j\)**를 비교해, 각 원소 별로 최대값을 취함:
     ```
     M_j[a, b] = max(M_j[a, b], M_i[a, b]) for all a,b
     ```
   - 그리고 “내가 이벤트를 수신했다”는 동작으로 \(M_j[j, j]\)를 +1 증가.

### 4) 어떤 이점이 있나?
- **프로세스 \(j\)**가 **프로세스 \(i\)**가 파악한 “다른 프로세스들의 상태”까지 한꺼번에 가져갈 수 있으므로, **분산 시스템 전체의 이벤트 인과관계**를 더 빠르게 공유할 수 있습니다.
- 하지만 각 노드마다 정보를 **\(N \times N\)**으로 관리해야 하므로, **오버헤드**가 커질 수 있습니다.

---

## 3. Version Vector

### 1) 어떤 상황에서 쓰는가?
- **버전 관리**, 특히 **분산 스토리지**(예: Cassandra, DynamoDB)나 **분산 파일 시스템**에서 **동일 데이터**를 여러 곳에서 동시에 수정할 수 있습니다.
- “동시에 수정된 것인지, 어느 것이 더 최신 버전인지”를 확인하기 위해, **버전 관리(Versioning)**가 필요합니다.

### 2) Vector Clock과의 관계
- **Version Vector**는 사실상 Vector Clock의 한 종류로, **“특정 데이터 객체”**의 **버전을 추적**하는 목적으로 사용됩니다.
  - 각 노드는 **해당 객체의 버전을 나타내는 벡터**를 갖고 있습니다.
  - 노드가 데이터를 업데이트할 때마다, 자기 인덱스(노드 ID)에 해당하는 버전을 +1 합니다.

### 3) 동작 예시
1. **노드 A, 노드 B가 동일 데이터 ‘X’를 복제해 가지고 있음**.
   - A의 버전: \([v_A, v_B]\)
   - B의 버전: \([x_A, x_B]\)
2. **A에서 X를 업데이트**하면, A는 자기 버전을 1 증가.
   - A의 새 버전: \([v_A+1, v_B]\)
3. **B도 동시에 X를 업데이트**할 수 있음.
   - B의 새 버전: \([x_A, x_B+1]\)
4. **동기화 시점**에 두 버전을 비교
   - 만약 \([1, 0]\) vs \([0, 1]\) 같은 식이면, “둘 다 서로 다른 독립 업데이트”라는 사실이 버전 벡터 비교로 드러남 → **충돌**로 판단하여 **머지(merge)** 또는 **충돌 해결**이 필요.
   - 만약 \([2, 0]\) vs \([1, 0]\)이라면, 전자가 더 “최신”이라고 볼 수 있음.

### 4) 요약
- Version Vector는 **“데이터 객체의 변화 이력”**을 각 노드가 **벡터 형태**로 추적하는 방식.
- **충돌(Concurrent Update) 여부** 판별에 유용하고, 현대의 분산 키-값 저장소, 파일 시스템 등에 널리 사용됩니다.

---

## 결론적으로

- **Vector Clock**:
  각 프로세스가 **N개 프로세스 각각의 카운터**를 유지. 이벤트가 일어날 때마다 자신 카운터 증가 + 메시지 교환 시 벡터 병합 → **동시성**, **인과관계**를 보다 정확히 파악.

- **Matrix Clock**:
  한 단계 더 나아가, **각 프로세스가 (다른 모든 프로세스의 Vector Clock)을 모두 저장**하는 **2차원 구조**. 분산 시스템 전체의 인과관계를 더 빠르게 동기화할 수 있지만, **메모리 사용** 등 오버헤드가 커짐.

- **Version Vector**:
  Vector Clock의 개념을 **특정 객체(데이터)의 버전 관리**에 적용한 것. 분산 스토리지나 파일 시스템에서, **동시에 업데이트**가 일어났는지, **어느 버전이 최신인지** 판별할 때 유용.

이들은 모두 **분산 시스템**에서 “이벤트 순서”를 정확히 파악하거나, “데이터 버전 충돌 여부”를 식별하려는 목적으로 쓰이는 **핵심 도구**들입니다. 이를 바탕으로 **분산 락, 트랜잭션, 충돌 해결** 등 다양한 문제를 효율적으로 처리할 수 있습니다.
```